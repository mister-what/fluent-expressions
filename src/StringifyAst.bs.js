// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';


function stringifyQuanifier(kind) {
  if (typeof kind === "string") {
    if (kind === "OneOrMore") {
      return "+";
    } else {
      return "?";
    }
  }
  var variant = kind.NAME;
  if (variant !== "MinMax") {
    if (variant === "Exact") {
      return "{" + (String(kind.VAL) + "}");
    } else {
      return "*" + (
              kind.VAL === "Lazy" ? "?" : ""
            );
    }
  }
  var match = kind.VAL;
  var min = match[0];
  if (min !== undefined) {
    var max = match[1];
    if (max !== undefined) {
      return "{" + (String(min) + ("," + (String(max) + "}")));
    } else {
      return "{" + (String(min) + ",}");
    }
  }
  var max$1 = match[1];
  if (max$1 !== undefined) {
    return "{," + (String(max$1) + "}");
  } else {
    return "{,}";
  }
}

function stringifyNode(_node, _parents) {
  while(true) {
    var parents = _parents;
    var node = _node;
    if (typeof node === "number") {
      return "";
    }
    switch (node.TAG | 0) {
      case /* Match */0 :
          var str = node._0;
          if (str.TAG) {
            return "[" + ((
                      str.negative ? "^" : ""
                    ) + (str.chars.map(function (kind) {
                              if (kind.NAME !== "Range") {
                                return kind.VAL;
                              }
                              var match = kind.VAL;
                              return match[0] + ("-" + match[1]);
                            }).join("") + "]"));
          } else {
            return str._0;
          }
      case /* ConcatExpr */1 :
          var right = node.right;
          var left = node.left;
          if (node.kind === "Conjunction") {
            return stringifyNode(left, {
                        hd: node,
                        tl: parents
                      }) + stringifyNode(right, {
                        hd: node,
                        tl: parents
                      });
          }
          if (parents) {
            var match = parents.hd;
            var exit = 0;
            if (typeof match !== "number") {
              switch (match.TAG | 0) {
                case /* ConcatExpr */1 :
                    if (match.kind === "Disjunction") {
                      exit = 2;
                    }
                    break;
                case /* NonCaptureGroup */4 :
                case /* CaptureGroup */5 :
                    exit = 2;
                    break;
                default:
                  
              }
            }
            if (exit === 2) {
              return stringifyNode(left, {
                          hd: node,
                          tl: parents
                        }) + ("|" + stringifyNode(right, {
                            hd: node,
                            tl: parents
                          }));
            }
            
          }
          return "(?:" + (stringifyNode(left, {
                        hd: node,
                        tl: parents
                      }) + ("|" + (stringifyNode(right, {
                            hd: node,
                            tl: parents
                          }) + ")")));
          break;
      case /* QuantifierExpr */2 :
          var node$1 = node.node;
          var exit$1 = 0;
          if (typeof node$1 === "number") {
            _parents = {
              hd: node,
              tl: parents
            };
            _node = node$1;
            continue ;
          }
          switch (node$1.TAG | 0) {
            case /* Match */0 :
                exit$1 = node$1._0.TAG ? 2 : 1;
                break;
            case /* NonCaptureGroup */4 :
            case /* CaptureGroup */5 :
                exit$1 = 2;
                break;
            default:
              exit$1 = 1;
          }
          switch (exit$1) {
            case 1 :
                return stringifyNode({
                            TAG: /* NonCaptureGroup */4,
                            node: node$1
                          }, {
                            hd: node,
                            tl: parents
                          }) + stringifyQuanifier(node.kind);
            case 2 :
                return stringifyNode(node$1, parents) + stringifyQuanifier(node.kind);
            
          }
          break;
      case /* LookaheadExpr */3 :
          var kind = node.kind;
          var lookahead = node.lookahead;
          return stringifyNode(node.node, {
                      hd: node,
                      tl: parents
                    }) + ("(?" + ((
                      kind === "Negative" && kind !== "Positive" ? "!" : "="
                    ) + (stringifyNode(lookahead, {
                            hd: {
                              TAG: /* NonCaptureGroup */4,
                              node: lookahead
                            },
                            tl: parents
                          }) + ")")));
      case /* NonCaptureGroup */4 :
          var node$2 = node.node;
          if (parents) {
            var tmp = parents.hd;
            if (typeof tmp !== "number") {
              switch (tmp.TAG | 0) {
                case /* NonCaptureGroup */4 :
                case /* CaptureGroup */5 :
                    _node = node$2;
                    continue ;
                default:
                  
              }
            }
            
          }
          return "(?:" + (stringifyNode(node$2, {
                        hd: node,
                        tl: parents
                      }) + ")");
      case /* CaptureGroup */5 :
          var name = node.name;
          var node$3 = node.node;
          if (name !== undefined) {
            return "(?<" + (name + (">" + (stringifyNode(node$3, {
                              hd: node,
                              tl: parents
                            }) + ")")));
          } else {
            return "(" + (stringifyNode(node$3, {
                          hd: node,
                          tl: parents
                        }) + ")");
          }
      
    }
  };
}

function stringify(param) {
  return {
          source: param.prefix + (stringifyNode(param.node, /* [] */0) + param.suffix),
          flags: param.flags
        };
}

exports.stringifyQuanifier = stringifyQuanifier;
exports.stringifyNode = stringifyNode;
exports.stringify = stringify;
/* No side effect */
